### 멀티 프로세싱

멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행

- 웹 브라우저는 멀티 프로세스 구조를 가지고 있다.

  (브라우저 프로세스, 랜더러 프로세스, 플러그인 프로세스, GPU 프로세스)

### IPC(Inter Process Communication)

프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘

메모리가 완전히 공유되는 스레드보다는 속도가 느리다.

커널에서 동작한다.

- 공유 메모리
  - 일반적으로 프로세스는 각자의 독립된 메모리를 가지지만 공유 메모리를 통해 여러 프로세스가 하나의 메모리를 공유할 수 있다.
  - IPC방식 중 어떠한 매개체를 통해 데이터를 주고받는 것이 아닌 메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르다.
  - 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요하다.
- 파일
  - 파일은 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터를 말하며 이를 기반으로 프로세스 간 통신을 한다.
- 소켓
  - 네트워크 소켓 통신을 통해 데이터를 공유한다.
- 익명 파이프
  - 부모와 자식 프로세스 간에만 사용할 수 있다. 외부 프로세스와의 통신은 불가능
  - FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 통신한다.
  - 단방향 방식이기 때문에 송수신을 모두 하기를 원한다면 2개의 파이프를 만들어야 한다.
- 네임드 파이프
  - 부모 프로세스와 무관한 외부 프로세스도 통신이 가능
  - 읽기와 쓰기가 모두 가능하지만 한번에 한 방향으로만 통신이 가능한 반이중통신이다.
  - 전이중통신을 위해서는 읽기 파이프와 쓰기 파이프 총 2개의 파이프를 만들어야 한다.
- 메시지 큐
  - 입출력 방식은 네임드 파이프와 동일하다.
  - 파이프는 데이터의 흐름이라면, 메시지 큐는 메모리 공간이다.
  - 파이프와 달리 다수의 프로세스 간 메시지를 전달할 수 있다.
  - 동기화 문제 쉽게 해결 가능하다.

### 스레드

스레드는 프로세스의 실행 가능한 가장 작은 단위이며 프로세스는 여러 스레드를 가질 수 있다.

프로세스 : 코드, 데이터, 스택, 힙을 각각 생성

스레드 : 코드, 데이터, 힙은 스레드끼리 서로 공유, 그 외의 영역만 각각 생성(스택, 레지스터)

### TCB(Thread Control Block)

1. 스레드 ID
   - 스레드가 생성될 때 운영체제에서 스레드에 할당하는 고유 식별자
2. 스레드 상태
   - 스레드가 시스템을 통해 진행됨에 따라 변경되는 스레드의 상태
3. CPU 정보
   - 스레드가 얼마나 진행되었는지, 어떤 데이터가 사용되고 있는지 등 OS가 알아야 하는 모든 정보가 포함
4. 우선 순위
   - 스레드 스케줄러가 READY 대기열에서 다음에 선택해야 하는 스레드를 결정하는 데 도움이 되는 다른 스레드에 대한 스레드의 가중치(또는 우선 순위)
5. PCB를 가리키는 포인터
   - 이 스레드 생성을 트리거한 프로세스를 가리키는 포인터
6. 이 스레드가 생성한 스레드를 가리키는 포인터
7. stack 포인터
   - 스레드가 함수 호출할때 저장하는 곳인 stack을 가리킨다.

### 사용자 레벨 스레드

- 운영체제 커널과 상관없이 사용자 공간에서 실행 및 관리되는 스레드
- 사용자 공간에서 스레드를 생성하고 관리하는 라이브러리를 통해 구현된다.
- 커널에 의해 직접 인식되지 않으므로, 커널은 단일 프로세스로 간주하고, 스레드의 스케줄링이나 관리를 하지 않는다.
- 스레드 전환, 생성, 종료 등 스레드 관련 작업이 사용자 공간에서 처리되기 때문에 매우 빠르고 가볍다.
- 하나의 사용자 수준 스레드가 블록되면, 해당 스레드를 관리하는 전체 프로세스가 블록될 수 있다.

### 커널 레벨 스레드

- 운영 체제 커널이 직접 관리하는 스레드로, 커널이 각 스레드를 인식하고 개별적으로 스케줄링한다.
- 스케줄링, 생성, 종료 등의 작업을 커널이 처리하므로, 커널 수준에서 스레드 간의 실행 순서 조정과 자원 배분이 가능하다.
- 한 스레드가 대기 상태로 들어가 blocking 되어도 다른 스레드는 실행을 계속할 수 있다.
- 사용자 수준 스레드에 비해 컨텍스트 스위칭 비용이 크고, 스레드 생성 및 전환에 커널 호출이 필요하기 때문에 오버헤드가 상대적으로 크다.

### 멀티 스레드 모델

- 다대일 모델
  - 여러 사용자 스레드를 하나의 커널 스레드에 매핑하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.
  - 한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.
  - 한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.
- 일대일 모델
  - 하나의 사용자 스레드를 각각 하나의 커널 스레드로 매핑한다.
  - 하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.
  - 사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.
  - Linux가 대표적인 일대일 모델을 사용하는 os이다.
- 다대다 모델
  - 여러 사용자 스레드를 여러 커널 스레드에 매핑한다. (사용자 스레드 ≤ 커널 스레드 숫자로 매핑한다)
  - 다대일 모델과 일대일 모델의 단점을 극복한다.
    - 진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.
  - 개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.

### 멀티스레딩 : 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법

### 공유자원(Shared Resource)

- 공유 자원은 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미한다. 공유 자원을 2개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 한다.

### 임계 영역(Critical Section)

- 멀티 스레드 프로그래밍에서 임계 영역은 공유 자원을 접근하는 코드 영역을 말한다. 대표적으로 전역 변수나 heap 메모리 영역이 있다.
- 임계 영역을 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 3가지가 있다.

### 동기화(Synchronization)

- 여러 프로세스나 스레드 간의 실행 순서를 조정하는 개념이다. 주된 목표는 공유 데이터의 일관성을 보장하고 정해진 순서에 맞춰 작업을 수행하는 것이다.

### 상호배제(Mutual Exclusion)

- 상호배제는 동시에 여러 프로세스나 스레드가 동일한 공유 자원에 접근하지 못하도록 보장하는 개념이다. 주된 목표는 공유 자원에 대한 충돌을 방지하는 것이다.

### 스핀락

- 스레드가 락을 얻을 때까지 무한 루프를 돌며 확인하는 동기화 매커니즘
- 스레드가 대기 상태로 전환되지 않기에 컨텍스트 스위칭이 일어나지 않는다. 따라서 CPU의 오버헤드를 줄일 수 있다.
- 무한 루프 속에서 반복해서 락을 확인하기 때문에 락의 획득이 빠르다.
- Busy waiting : 무한루프를 돌면서 CPU를 계속 사용하기 때문에 오버헤드가 발생할 수 있다.
- Starvation (기아 상태) : 특정 스레드나 프로세스가 공유 자원을 오랫동안 점유한다면, 다른 스레드들이 대기 상태에 갇힐 수 있다.

### 뮤텍스

- 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막고, 오직 하나의 스레드만 접근 가능하도록 하는 변수이다.
- 0 또는 1의 값을 가지는 바이너리 세마포어와 유사하다. 임계 구역을 가진 스레드들의 실행 시간을 서로 겹치지 않게 단독으로 실행하게 하는 기법.

### 세마포어

- 신호기, 깃발을 의미하며 각 프로세스에 제어 신호를 전달하여 순서대로 작업하도록 하는 기법
- 세마포어는 동시에 리소스에 접근할 수 있는 '허용 가능한 Counter의 갯수'라고 보면된다. Counter 개수만큼 공유자원에 접근할 수 있다. 이 세마포어 개수에 따라 1개면 이진 세마포어, 2개 이상의 경우면 카운팅 세마포어 라고 불린다.
- 간단한 정수 값과 두 가지 함수 wait(P 함수라고도 함) 및 signal(V 함수라고도 함)로 공유 자원에 대한 접근을 처리한다.
  - 잠금 함수 : P (try)
  - 잠금 해제 함수 : V (increment)
  - sem < 0 : 프로세스가 처리부분을 처리하고 있다는 뜻이므로 대기

### 바이너리 세마포어

- 0과 1의 두 가지 값만 가질 수 있는 세마포어
- 구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어라고 할 수 있다.
- 하지만 엄밀히 말하면 뮤텍스는 리소스에 대한 접근을 동기화하는 데 사용되는 잠금 메커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 메커니즘이다.

### 카운팅 세마포어

- 여러 개의 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는 데 사용된다.

### 모니터

- 모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게  접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다.

- 어떤 공유 데이터에 대해 모니터를 지정해놓으면, 프로세스는 그 데이터에 접근하기 위해 모니터에 들어가야만 한다. 즉, 모니터 내부에 들어간 프로세스에게만 공유 데이터를 접근할 수 있는 기능을 제공하는 것이다. 또한, 프로세스가 모니터에 들어가고자 할 때, 다른 프로세스가 모니터 내부에 있다면 입장 큐에서 기다려야 한다.

### 교착상태

교착 상태(deadlock)는 2개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 의미한다.

교착 상태의 원인

- 상호 배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능하다.
- 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
- 환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 의미한다.

## 🚀 추가

### 프로세스 VS 스레드

- 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있다. 하지만 프로세스 생성은 많은 시간과 자원을 소비한다.
- 스레드는 프로세스의 실행 단위로 프로세스 내의 주소 공간과 자원을 공유한다. 그러나 스레드도 독립적인 작업을 수행해야 하기 때문에 각자 스택과 PC 레지스터 값을 갖고 있다.
- 스레드는 프로세스보다 생성 및 종료 시간, 스레드 간 전환 시간이 짧다.
- 스레드는 프로세스의 메모리, 자원 등을 공유하므로 프로세스 간 통신 (IPC)을 사용하지 않고도 데이터를 공유할 수 있기 때문에, 자원의 효율적인 활용이 가능해 시스템 자원 소모가 줄어든다.

### 뮤텍스 vs 세마포어

- 세마포어: 열쇠의 개수

- 뮤텍스: 열쇠

  가장 큰 차이점은 `동기화 대상의 개수`이다.

- 세마포어는 동기화 대상이 여러개 일 때, 뮤텍스는 동기화 대상이 오직 하나 일 때 사용된다.

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.

- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 책임을 진다.

- 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 뮤텍스를 해제할 수 있다. 하지만, 세마포어는 소유하지 않고 있는 스레드가 세마포어를 해제할 수 있다.

- 세마포어는 시스템 범위에 걸쳐있고 파일 시스템 상의 파일 형태로 존재한다. 하지만 뮤텍스는 프로세스 범위를 가지고 프로그램이 종료될 때 자동으로 지워진다.

### 모니터 vs 세마포어

- 세마포어는 동기화 함수의 제약 조건을 고려해야하는 반면, 모니터는 프로시저(함수)를 호출하여 간단히 해결할 수 있다.

### 스레드를 많이 쓸수록 성능이 좋아질까?

1. 임계영역에 대한 동기화 비용
   - 여러 개의 스레드가 임계 영역의 공유 자원에 접근할 수 있기 때문에, 데이터의 일관성과 정확성을 유지하기 위해 동기화 기법을 사용하여야 한다.
   - 뮤텍스나 세마포어와 같은 동기화 기법을 사용하는 경우 스레드가 데이터에 접근하기 전에 락(Lock)을 획득하고, 데이터에 접근한 후에 락을 해제하는데, 이러한 락 획득 및 해제 작업은 추가적인 시간이 소요되며, 나머지 스레드의 실행을 중지하거나, 대기하게 만들어야 하므로 프로그램의 성능이 저하될 수 있다.
   - CPU 캐시와 메모리 사이의 캐시 데이터 일관성 문제도 발생할 수 있는데, 여러 개의 스레드가 동시에 공유하는 메모리나 데이터에 대해 수정을 가할때 특정 CPU 코어의 캐시에 저장된 데이터와 다른 CPU 코어의 캐시에 저장된 데이터가 일치하지 않는 경우가 발생한다. 이럴 경우, 다른 CPU 코어에서 변경한 데이터가 현재 CPU 코어의 캐시에 반영되지 않은 상태로 사용되어 문제가 발생할 수 있어, CPU 캐시에서 데이터를 불러오는 비용이 발생하므로 성능에 영향을 미치게 된다.
   - 따라서 멀티 스레드 프로그램이 많은 양의 공유 데이터를 사용하는 경우 동기화 및 캐시 일관성 작업으로 인해 병목이 일어나 성능이 떨어진다.
2. 컨텍스트 스위칭 오버헤드
   - 스레드가 많으면 많을 수록 스위칭 횟수도 많아지고 덩달아 오버헤드도 많아져 성능이 저하될 수 있다는 의미이다.
3. 잔여 스레드의 리소스 낭비
   - 멀티 스레드 어플리케이션에서 이용률이 한산하여 스레드를 한두개 밖에 이용하지 않을때, 나머지 잔여 스레드들이 CPU, 메모리, 네트워크 등의 자원을 불필요하게 점유해서 성능 저하나 오류의 원인이 될 수 있게 된다.
   - 놀고 있는 스레드가 많을 수록 불필요하게 메모리를 차지하고 있는 셈이기 때문에 시스템 자원 낭비가 발생된다. 그런데 놀고 있음에도 CPU는 다른 스레드에게 CPU 시간을 양도하도록 설계 되어 있기 때문에 노는 스레드와 다른 스레드 간에 컨텍스트 스위칭을 하여 CPU의 효율성을 떨어뜨린다.